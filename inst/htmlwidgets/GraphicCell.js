// Generated by CoffeeScript 1.8.0
var GraphicCell,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

GraphicCell = (function(_super) {
  __extends(GraphicCell, _super);

  function GraphicCell() {
    return GraphicCell.__super__.constructor.apply(this, arguments);
  }

  GraphicCell.validRootAttributes = ['background-color', 'baseImage', 'columnGutter', 'debugBorder', 'font-color', 'font-family', 'font-size', 'font-weight', 'layout', 'numCols', 'numImages', 'numRows', 'padding', 'proportion', 'rowGutter', 'image-background-color', 'text-footer', 'text-header', 'text-overlay', 'variableImage'];

  GraphicCell.prototype.setConfig = function(config) {
    var invalidRootAttributes, key, paddingBottom, paddingLeft, paddingRight, paddingTop, validLayoutValues, _ref;
    this.config = _.cloneDeep(config);
    invalidRootAttributes = _.difference(_.keys(this.config), GraphicCell.validRootAttributes);
    if (invalidRootAttributes.length > 0) {
      throw new Error("Invalid attribute(s): " + (JSON.stringify(invalidRootAttributes)));
    }
    if (this.config.variableImage == null) {
      throw new Error("Must specify 'variableImage'");
    }
    if (_.isString(this.config['proportion']) && this.config['proportion'].startsWith('=')) {
      this.config['proportion'] = eval(this.config['proportion'].substring(1));
    }
    this._verifyKeyIsFloat(this.config, 'proportion', 1, 'Must be number between 0 and 1');
    this._verifyKeyIsRatio(this.config, 'proportion');
    this._verifyKeyIsPositiveInt(this.config, 'numImages', 1);
    if (this.config['numRows'] != null) {
      this._verifyKeyIsPositiveInt(this.config, 'numRows', 1);
    }
    if (this.config['numCols'] != null) {
      this._verifyKeyIsPositiveInt(this.config, 'numCols', 1);
    }
    if ((this.config['numRows'] != null) && (this.config['numCols'] != null)) {
      throw new Error("Cannot specify both numRows and numCols. Choose one, and use numImages to control exact dimensions.");
    }
    this._verifyKeyIsFloat(this.config, 'columnGutter', 0.05, 'Must be number between 0 and 1');
    this._verifyKeyIsRatio(this.config, 'columnGutter');
    this._verifyKeyIsFloat(this.config, 'rowGutter', 0.05, 'Must be number between 0 and 1');
    this._verifyKeyIsRatio(this.config, 'rowGutter');
    this._processTextConfig('text-header');
    this._processTextConfig('text-overlay');
    this._processTextConfig('text-footer');
    if (this.config.padding) {
      _ref = this.config.padding.split(" "), paddingTop = _ref[0], paddingRight = _ref[1], paddingBottom = _ref[2], paddingLeft = _ref[3];
      this.config.padding = {
        top: parseInt(paddingTop.replace(/(px|em)/, '')),
        right: parseInt(paddingRight.replace(/(px|em)/, '')),
        bottom: parseInt(paddingBottom.replace(/(px|em)/, '')),
        left: parseInt(paddingLeft.replace(/(px|em)/, ''))
      };
      for (key in this.config.padding) {
        if (_.isNaN(this.config.padding[key])) {
          throw new Error("Invalid padding " + this.config.padding + ": " + key + " must be Integer");
        }
      }
    } else {
      this.config.padding = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    if (this.config.layout) {
      validLayoutValues = d3.layout.grid().validDirections();
      if (!validLayoutValues.includes(this.config.layout)) {
        throw new Error("Invalid layout " + this.config.layout + ". Valid values: [" + (validLayoutValues.join('|')) + "]");
      }
    }
  };

  GraphicCell.prototype._processTextConfig = function(key) {
    var cssAttribute, textConfig, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
    if (this.config[key] != null) {
      textConfig = _.isString(this.config[key]) ? {
        text: this.config[key]
      } : this.config[key];
      if (textConfig['text'] == null) {
        throw new Error("Invalid " + key + " config: must have text field");
      }
      if ((textConfig != null) && textConfig['text'].match(/^percentage$/)) {
        textConfig['text'] = "" + ((100 * this.config.proportion).toFixed(1).replace(/\.0$/, '')) + "%";
      }
      if ((textConfig != null) && textConfig['text'].match(/^proportion$/)) {
        textConfig['text'] = "" + (this.config.proportion.toFixed(3).replace(/0+$/, ''));
      }
      if (textConfig['font-size'] == null) {
        textConfig['font-size'] = BaseCell.getDefault('font-size');
      }
      if (textConfig['horizontal-align'] == null) {
        textConfig['horizontal-align'] = 'middle';
      }
      if ((_ref = textConfig['horizontal-align']) === 'center' || _ref === 'centre') {
        textConfig['horizontal-align'] = 'middle';
      }
      if ((_ref1 = textConfig['horizontal-align']) === 'left') {
        textConfig['horizontal-align'] = 'start';
      }
      if ((_ref2 = textConfig['horizontal-align']) === 'right') {
        textConfig['horizontal-align'] = 'end';
      }
      this._verifyKeyIsPositiveInt(textConfig, 'padding-left', 1);
      this._verifyKeyIsPositiveInt(textConfig, 'padding-right', 1);
      if ((_ref3 = textConfig['horizontal-align']) !== 'start' && _ref3 !== 'middle' && _ref3 !== 'end') {
        throw new Error("Invalid horizontal align " + textConfig['horizontal-align'] + " : must be one of ['left', 'center', 'right']");
      }
      _ref4 = ['font-family', 'font-size', 'font-weight', 'font-color'];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        cssAttribute = _ref4[_i];
        if (textConfig[cssAttribute] != null) {
          this.setCss(key, cssAttribute, textConfig[cssAttribute]);
        }
      }
      return this.config[key] = textConfig;
    }
  };

  GraphicCell.prototype._draw = function() {
    var backgroundRect, d3Data, enteringLeafNodes, graphicContainer, gridLayout, imageHeight, imageWidth, textSpanWidth, yMidpoint;
    this._computeDimensions();
    this.parentSvg.append("svg:rect").attr('width', this.width).attr('height', this.height).attr('class', 'background-rect').attr('fill', this.config['background-color'] || 'none');
    if (this.config['text-header'] != null) {
      textSpanWidth = this.dimensions.headerXOffset + this.dimensions.headerWidth;
      yMidpoint = this.dimensions.headerYOffset + this.dimensions.headerHeight / 2;
      this._addTextTo(this.parentSvg, 'text-header', this.config['text-header'], textSpanWidth, yMidpoint);
    }
    graphicContainer = this.parentSvg.append('g').attr('class', 'graphic-container').attr('transform', "translate(" + this.dimensions.graphicXOffset + "," + this.dimensions.graphicYOffset + ")");
    if (this.config['text-footer'] != null) {
      textSpanWidth = this.dimensions.footerXOffset + this.dimensions.footerWidth;
      yMidpoint = this.dimensions.footerYOffset + this.dimensions.footerHeight / 2;
      this._addTextTo(this.parentSvg, 'text-footer', this.config['text-footer'], textSpanWidth, yMidpoint);
    }
    d3Data = this._generateDataArray(this.config.proportion, this.config.numImages);
    gridLayout = d3.layout.grid().bands().size([this.dimensions.graphicWidth, this.dimensions.graphicHeight]).padding([this.config['columnGutter'], this.config['rowGutter']]);
    if (this.config['numRows'] != null) {
      gridLayout.rows(this.config['numRows']);
    }
    if (this.config['numCols'] != null) {
      gridLayout.cols(this.config['numCols']);
    }
    if (_.isString(this.config.variableImage)) {
      if (this.config.variableImage.match(/fromleft/)) {
        gridLayout.direction('right,down');
      }
      if (this.config.variableImage.match(/fromright/)) {
        gridLayout.direction('left,down');
      }
      if (this.config.variableImage.match(/fromtop/)) {
        gridLayout.direction('right,down');
      }
      if (this.config.variableImage.match(/frombottom/)) {
        gridLayout.direction('right,up');
      }
    }
    if (this.config.layout) {
      gridLayout.direction(this.config.layout);
    }
    enteringLeafNodes = graphicContainer.selectAll(".node").data(gridLayout(d3Data)).enter().append("g").attr("class", function(d) {
      var cssLocation;
      cssLocation = "node-index-" + d.i + " node-xy-" + d.row + "-" + d.col;
      return "node " + cssLocation;
    }).attr("transform", function(d) {
      return "translate(" + d.x + "," + d.y + ")";
    });
    imageWidth = gridLayout.nodeSize()[0];
    imageHeight = gridLayout.nodeSize()[1];
    backgroundRect = enteringLeafNodes.append("svg:rect").attr('width', imageWidth).attr('height', imageHeight).attr('class', 'single-image-background-rect').attr('fill', this.config['image-background-color'] || 'none');
    if (this.config['debugBorder'] != null) {
      backgroundRect.attr('stroke', 'black').attr('stroke-width', '1');
    }
    if (this.config.baseImage != null) {
      enteringLeafNodes.each(_.partial(ImageFactory.addImageTo, this.config.baseImage, imageWidth, imageHeight));
    }
    enteringLeafNodes.each(_.partial(ImageFactory.addImageTo, this.config.variableImage, imageWidth, imageHeight));
    if (this.config['tooltip']) {
      enteringLeafNodes.append("svg:title").text(this.config['tooltip']);
    }
    if (this.config['text-overlay'] != null) {
      textSpanWidth = gridLayout.nodeSize()[0];
      yMidpoint = gridLayout.nodeSize()[1] / 2;
      return this._addTextTo(enteringLeafNodes, 'text-overlay', this.config['text-overlay'], textSpanWidth, yMidpoint);
    }
  };

  GraphicCell.prototype._computeDimensions = function() {
    this.dimensions = {};
    this.dimensions.headerHeight = 0 + (this.config['text-header'] != null ? parseInt(this.config['text-header']['font-size'].replace(/(px|em)/, '')) : 0);
    this.dimensions.footerHeight = 0 + (this.config['text-footer'] != null ? parseInt(this.config['text-footer']['font-size'].replace(/(px|em)/, '')) : 0);
    this.dimensions.headerWidth = this.width - this.config.padding.left - this.config.padding.right;
    this.dimensions.headerXOffset = 0 + this.config.padding.left;
    this.dimensions.headerYOffset = 0 + this.config.padding.top;
    this.dimensions.graphicWidth = this.width - this.config.padding.left - this.config.padding.right;
    this.dimensions.graphicHeight = this.height - this.dimensions.headerHeight - this.dimensions.footerHeight - this.config.padding.top - this.config.padding.bottom;
    this.dimensions.graphicXOffset = 0 + this.config.padding.left;
    this.dimensions.graphicYOffset = 0 + this.dimensions.headerYOffset + this.dimensions.headerHeight;
    this.dimensions.footerWidth = this.width - this.config.padding.left - this.config.padding.right;
    this.dimensions.footerXOffset = 0 + this.config.padding.left;
    return this.dimensions.footerYOffset = 0 + this.dimensions.graphicYOffset + this.dimensions.graphicHeight;
  };

  GraphicCell.prototype._addTextTo = function(parent, myClass, textConfig, textSpanWidth, yMidpoint) {
    var x;
    x = (function() {
      switch (false) {
        case textConfig['horizontal-align'] !== 'start':
          return 0 + textConfig['padding-left'];
        case textConfig['horizontal-align'] !== 'middle':
          return textSpanWidth / 2;
        case textConfig['horizontal-align'] !== 'end':
          return textSpanWidth - textConfig['padding-right'];
      }
    })();
    return parent.append('svg:text').attr('class', myClass).attr('x', x).attr('y', yMidpoint).attr('text-anchor', textConfig['horizontal-align']).style('alignment-baseline', 'central').style('dominant-baseline', 'central').text(textConfig.text);
  };

  GraphicCell.prototype._generateDataArray = function(proportion, numImages) {
    var d3Data, i, proportionForImageI, remainingArea, _i;
    d3Data = [];
    remainingArea = proportion * numImages;
    for (i = _i = 0; 0 <= numImages ? _i < numImages : _i > numImages; i = 0 <= numImages ? ++_i : --_i) {
      proportionForImageI = remainingArea > 1 ? 1 : remainingArea;
      remainingArea -= proportionForImageI;
      d3Data.push({
        proportion: proportionForImageI,
        i: i
      });
    }
    return d3Data;
  };

  return GraphicCell;

})(BaseCell);
