// Generated by CoffeeScript 1.8.0
var LabelCell,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

LabelCell = (function(_super) {
  __extends(LabelCell, _super);

  function LabelCell() {
    return LabelCell.__super__.constructor.apply(this, arguments);
  }

  LabelCell.prototype.setConfig = function(config) {
    var _base, _ref, _ref1;
    this.config = config;
    this.labels = [];
    if (_.isString(this.config)) {
      this.labels = [
        {
          text: this.config
        }
      ];
      this.config = {};
    } else if (_.isArray(this.config)) {
      this.labels = this.config.map(function(labelConfig) {
        if (_.isString(labelConfig)) {
          return {
            text: labelConfig
          };
        } else {
          return labelConfig;
        }
      });
      this.config = {};
    } else if (_.has(this.config, 'labels')) {
      this.labels = this.config.labels.map(function(labelConfig) {
        if (_.isString(labelConfig)) {
          return {
            text: labelConfig
          };
        } else {
          return labelConfig;
        }
      });
    } else {
      this.labels = [this.config];
    }
    this._verifyKeyIsInt(this.config, 'padding-top', 0);
    this._verifyKeyIsInt(this.config, 'padding-inner', 0);
    this._verifyKeyIsInt(this.config, 'padding-bottom', 0);
    this._verifyKeyIsInt(this.config, 'padding-right', 0);
    this._verifyKeyIsInt(this.config, 'padding-left', 0);
    if ((_base = this.config)['vertical-align'] == null) {
      _base['vertical-align'] = 'center';
    }
    if ((_ref = this.config['vertical-align']) === 'middle' || _ref === 'centre') {
      this.config['vertical-align'] = 'center';
    }
    if ((_ref1 = this.config['vertical-align']) !== 'top' && _ref1 !== 'center' && _ref1 !== 'bottom') {
      throw new Error("Invalid vertical align " + this.config['vertical-align'] + " : must be one of ['top', 'center', 'bottom']");
    }
    this.allocatedVerticalSpace = 0;
    _.forEach(this.labels, (function(_this) {
      return function(labelConfig, index) {
        var _ref2, _ref3, _ref4, _ref5;
        if (labelConfig['class'] == null) {
          labelConfig['class'] = "label-" + index;
        }
        if (labelConfig['horizontal-align'] == null) {
          labelConfig['horizontal-align'] = 'middle';
        }
        if ((_ref2 = labelConfig['horizontal-align']) === 'center' || _ref2 === 'centre') {
          labelConfig['horizontal-align'] = 'middle';
        }
        if ((_ref3 = labelConfig['horizontal-align']) === 'left') {
          labelConfig['horizontal-align'] = 'start';
        }
        if ((_ref4 = labelConfig['horizontal-align']) === 'right') {
          labelConfig['horizontal-align'] = 'end';
        }
        if ((_ref5 = labelConfig['horizontal-align']) !== 'start' && _ref5 !== 'middle' && _ref5 !== 'end') {
          throw new Error("Invalid horizontal align " + labelConfig['horizontal-align'] + " : must be one of ['left', 'center', 'right']");
        }
        if (labelConfig['font-size'] == null) {
          labelConfig['font-size'] = BaseCell.getDefault('font-size');
        }
        _.forEach(labelConfig, function(labelValue, labelKey) {
          if (labelKey === 'class' || labelKey === 'text' || labelKey === 'horizontal-align') {
            return;
          }
          return _this.setCss(labelConfig['class'], labelKey, labelValue);
        });
        return _this.allocatedVerticalSpace += parseInt(labelConfig['font-size'].replace(/(px|em)/, ''));
      };
    })(this));
    return this.allocatedVerticalSpace += this.config['padding-inner'] * this.labels.length - 1;
  };

  LabelCell.prototype.computeHorizontalOffset = function(horizontalAlign) {
    switch (false) {
      case horizontalAlign !== 'start':
        return this.config['padding-left'];
      case horizontalAlign !== 'middle':
        return this.width / 2;
      case horizontalAlign !== 'end':
        return this.width - this.config['padding-right'];
    }
  };

  LabelCell.prototype.computeInitialVerticalOffset = function(verticalAlign) {
    var freeVertSpace;
    freeVertSpace = this.height - this.config['padding-top'] - this.config['padding-bottom'] - this.allocatedVerticalSpace;
    if (freeVertSpace < 0) {
      console.log(freeVertSpace);
      console.error("Label is using too much vertical space");
      freeVertSpace = 0;
    }
    switch (false) {
      case verticalAlign !== 'top':
        return this.config['padding-top'];
      case verticalAlign !== 'center':
        return this.config['padding-top'] + freeVertSpace / 2;
      case verticalAlign !== 'bottom':
        return this.config['padding-top'] + freeVertSpace;
    }
  };

  LabelCell.prototype._draw = function() {
    var currentY;
    if (this.config['background-color']) {
      this.parentSvg.append('svg:rect').attr('class', 'background').attr('width', this.width).attr('height', this.height).attr('fill', this.config['background-color']);
    }
    currentY = this.computeInitialVerticalOffset(this.config['vertical-align']);
    return _.forEach(this.labels, (function(_this) {
      return function(labelConfig) {
        var fontSize, xOffset;
        fontSize = parseInt(labelConfig['font-size'].replace(/(px|em)/, ''));
        xOffset = _this.computeHorizontalOffset(labelConfig['horizontal-align']);
        _this._addTextTo(_this.parentSvg, labelConfig['text'], labelConfig['class'], labelConfig['horizontal-align'], xOffset, currentY + fontSize / 2);
        return currentY += fontSize + _this.config['padding-inner'];
      };
    })(this));
  };

  LabelCell.prototype._addTextTo = function(parent, text, myClass, textAnchor, x, y) {
    return parent.append('svg:text').attr('class', myClass).attr('x', x).attr('y', y).attr('text-anchor', textAnchor).style('alignment-baseline', 'central').style('dominant-baseline', 'central').text(text);
  };

  return LabelCell;

})(BaseCell);
